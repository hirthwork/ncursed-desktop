--- a/mcabber/compl.c
+++ b/mcabber/compl.c
@@ -113,15 +113,28 @@
 // Frees reserved id for category.
 // Note, that for now it not validates its input, so, be careful
 // and specify exactly what you get from compl_new_category.
-void compl_del_category(guint id)
+void compl_del_category(guint categ)
 {
-  if (!id) {
-    scr_log_print(LPRINT_LOGNORM, "Error: compl_del_category() - "
+  guint64 catv;
+  GSList *sl_cat;
+
+  if (categ) {
+    categ--;
+    catv = 1UL << categ;
+
+    // Look for category
+    for (sl_cat=Categories; sl_cat; sl_cat = g_slist_next(sl_cat)) {
+      if (catv == ((category*)sl_cat->data)->flag)
+        break;
+    }
+    if (sl_cat) {
+      Categories = g_slist_delete_link(Categories, sl_cat);
+      registered_cats &= ~catv;
+    }
+  } else {
+    scr_log_print(LPRINT_LOGNORM, "Error: compl_del_category() - "
                   "Invalid category.");
-    return;
   }
-  id--;
-  registered_cats &= ~(1<<id);
 }
 #endif

@@ -159,11 +172,11 @@
           compval = g_strdup_printf("%s%s", word+len, suffix);
         else
           compval = g_strdup(word+len);
-        c->list = g_slist_insert_sorted(c->list, compval,
-                                        (GCompareFunc)g_ascii_strcasecmp);
+        c->list = g_slist_prepend(c->list, compval);
       }
     }
   }
+  c->list = g_slist_reverse(c->list);
   c->next = c->list;
   InputCompl = c;
   return g_slist_length(c->list);
@@ -218,39 +234,41 @@
   return r;
 }

-
 /* Categories functions */

-//  compl_add_category_word(categ, command)
-// Adds a keyword as a possible completion in category categ.
-void compl_add_category_word(guint categ, const gchar *word)
+static category* prepare_category(guint categ, _Bool create)
 {
   guint64 catv;
   GSList *sl_cat;
-  category *cat;
-  char *nword;
+  category *cat = 0;

-  if (!categ) {
+  if (categ) {
+    categ--;
+    catv = 1UL << categ;
+
+    // Look for category
+    for (sl_cat=Categories; sl_cat; sl_cat = g_slist_next(sl_cat)) {
+      if (catv == ((category*)sl_cat->data)->flag)
+        break;
+    }
+    if (!sl_cat) {   // Category not found, let's create it
+      if (create) {
+        cat = g_new0(category, 1);
+        cat->flag = catv;
+        Categories = g_slist_append(Categories, cat);
+      }
+    } else
+      cat = (category*)sl_cat->data;
+  } else {
-    scr_log_print(LPRINT_LOGNORM, "Error: compl_add_category_word() - "
+    scr_log_print(LPRINT_LOGNORM, "Error: prepare_category() - "
                   "Invalid category.");
-    return;
-  }
-
-  categ--;
-  catv = 1UL << categ;
-
-  // Look for category
-  for (sl_cat=Categories; sl_cat; sl_cat = g_slist_next(sl_cat)) {
-    if (catv == ((category*)sl_cat->data)->flag)
-      break;
   }
-  if (!sl_cat) {   // Category not found, let's create it
-    cat = g_new0(category, 1);
-    cat->flag = catv;
-    Categories = g_slist_append(Categories, cat);
-  } else
-    cat = (category*)sl_cat->data;
+  return cat;
+}

+static const gchar* prepare_word(const gchar* word)
+{
+  const gchar* nword;
   // If word is not space-terminated, we add one trailing space
   for (nword = (char*)word; *nword; nword++)
     ;
@@ -260,59 +278,69 @@
   } else {              // word is fine
     nword = g_strdup(word);
   }
+  return nword;
+}

-  if (g_slist_find_custom(cat->words, nword, (GCompareFunc)g_strcmp0) != NULL)
-    return;
+//  compl_add_category_word(categ, command)
+// Adds a keyword as a possible completion in category categ.
+void compl_add_category_word(guint categ, const gchar *word)
+{
+  const gchar *nword;
+  category *cat = prepare_category(categ, 1);

-  cat->words = g_slist_insert_sorted(cat->words, nword,
-                                     (GCompareFunc)g_ascii_strcasecmp);
+  if (cat) {
+    nword = prepare_word(word);
+
+    if (g_slist_find_custom(cat->words, nword, (GCompareFunc)g_strcmp0) != NULL) {
+      g_free(nword);
+      return;
+    }
+
+    cat->words = g_slist_insert_sorted(cat->words, nword,
+                                       (GCompareFunc)g_ascii_strcasecmp);
+  }
 }

-//  compl_del_category_word(categ, command)
-// Removes a keyword from category categ in completion list.
-void compl_del_category_word(guint categ, const gchar *word)
+//  compl_add_category_word(categ, command)
+// Adds a keyword as a possible completion in category categ.
+// New keyword will be put at the begginning of the category keywords list.
+void compl_add_unordered_category_word(guint categ, const gchar *word)
 {
-  guint64 catv;
-  GSList *sl_cat, *sl_elt;
-  category *cat;
-  char *nword;
+  const gchar *nword;
+  category *cat = prepare_category(categ, 1);

-  if (!categ) {
-    scr_log_print(LPRINT_LOGNORM, "Error: compl_del_category_word() - "
-                  "Invalid category.");
-    return;
-  }
+  if (cat) {
+    nword = prepare_word(word);

-  categ--;
-  catv = 1UL << categ;
+    if (g_slist_find_custom(cat->words, nword, (GCompareFunc)g_strcmp0) != NULL) {
+      g_free(nword);
+      return;
+    }

-  // Look for category
-  for (sl_cat=Categories; sl_cat; sl_cat = g_slist_next(sl_cat)) {
-    if (catv == ((category*)sl_cat->data)->flag)
-      break;
+    cat->words = g_slist_prepend(cat->words, nword);
   }
-  if (!sl_cat) return;   // Category not found, finished!
+}

-  cat = (category*)sl_cat->data;
+//  compl_del_category_word(categ, command)
+// Removes a keyword from category categ in completion list.
+void compl_del_category_word(guint categ, const gchar *word)
+{
+  GSList *sl_elt;
+  char *nword;
+  category *cat = prepare_category(categ, 0);

-  // If word is not space-terminated, we add one trailing space
-  for (nword = (char*)word; *nword; nword++)
-    ;
-  if (nword > word) nword--;
-  if (*nword != ' ') {  // Add a space
-    nword = g_strdup_printf("%s ", word);
-  } else {              // word is fine
-    nword = g_strdup(word);
-  }
+  if (cat) {
+    nword = prepare_word(word);

-  sl_elt = cat->words;
-  while (sl_elt) {
-    if (!strcasecmp((char*)sl_elt->data, nword)) {
-      g_free(sl_elt->data);
-      cat->words = g_slist_delete_link(cat->words, sl_elt);
-      break; // Only remove first occurence
+    sl_elt = cat->words;
+    while (sl_elt) {
+      if (!strcasecmp((char*)sl_elt->data, nword)) {
+        g_free(sl_elt->data);
+        cat->words = g_slist_delete_link(cat->words, sl_elt);
+        break; // Only remove first occurence
+      }
+      sl_elt = g_slist_next(sl_elt);
     }
-    sl_elt = g_slist_next(sl_elt);
   }
 }

--- a/mcabber/compl.h
+++ b/mcabber/compl.h
@@ -35,6 +35,7 @@
 #endif

 void    compl_add_category_word(guint categ, const gchar *command);
+void    compl_add_unordered_category_word(guint categ, const gchar *command);
 void    compl_del_category_word(guint categ, const gchar *word);
 GSList *compl_get_category_list(guint categ, guint *dynlist);

--- a/mcabber/settings.c
+++ b/mcabber/settings.c
@@ -96,7 +96,6 @@
 //
 int cfg_read_file(char *filename, guint mainfile)
 {
-  static unsigned int runtime;
   FILE *fp;
   char *buf;
   char *line, *eol;
@@ -183,46 +182,11 @@
     if ((*line == '\n') || (*line == '\0') || (*line == '#'))
       continue;

-    // We only allow assignments line, except for commands "pgp", "source",
-    // "color", "load" and "otrpolicy", unless we're in runtime (i.e. not startup).
-    if (runtime ||
-        (strchr(line, '=') != NULL)        ||
-        startswith(line, "pgp ", FALSE)    ||
-        startswith(line, "source ", FALSE) ||
-        startswith(line, "color ", FALSE)  ||
-#ifdef MODULES_ENABLE
-        startswith(line, "module ", FALSE) ||
-#endif
-        startswith(line, "status ", FALSE) ||
-        startswith(line, "otrpolicy", FALSE)) {
-      // Only accept a few "safe" commands
-      if (!runtime &&
-          !startswith(line, "set ", FALSE)    &&
-          !startswith(line, "bind ", FALSE)   &&
-          !startswith(line, "alias ", FALSE)  &&
-          !startswith(line, "pgp ", FALSE)    &&
-          !startswith(line, "source ", FALSE) &&
-          !startswith(line, "status ", FALSE) &&
-          !startswith(line, "color ", FALSE)  &&
-#ifdef MODULES_ENABLE
-          !startswith(line, "module ", FALSE) &&
-#endif
-          !startswith(line, "otrpolicy ", FALSE)) {
-        scr_LogPrint(LPRINT_LOGNORM, "Error in configuration file (l. %d): "
-                     "this command can't be used here", ln);
-        err++;
-        continue;
-      }
-      // Set the leading COMMAND_CHAR to build a command line
-      // and process the command
-      *(--line) = COMMAND_CHAR;
-      if (process_command(line, TRUE) == 255)
-        mcabber_set_terminate_ui();
-    } else {
-      scr_LogPrint(LPRINT_LOGNORM, "Error in configuration file (l. %d): "
-                   "this is not an assignment", ln);
-      err++;
-    }
+    // Set the leading COMMAND_CHAR to build a command line
+    // and process the command
+    *(--line) = COMMAND_CHAR;
+    if (process_command(line, TRUE) == 255)
+      mcabber_set_terminate_ui();
   }
   g_free(buf);
   fclose(fp);
@@ -231,10 +195,6 @@
     scr_LogPrint(LPRINT_LOGNORM, "Loaded %s.", filename);

 cfg_read_file_return:
-  // If we're done with the main file parsing, we can assume that
-  // the next time this function is called will be at run time.
-  if (mainfile)
-    runtime = TRUE;
   return err;
 }
